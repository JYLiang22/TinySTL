#include<iostream>
#include"../include/MyRedBlackTree.h"

// class Node构造函数定义
template<typename Key, typename Value>
MyRedBlackTree<Key, Value>::Node::Node()
    : color(Color::black), left(nullptr), right(nullptr), parent(nullptr) {}

template<typename Key, typename Value>
MyRedBlackTree<Key, Value>::Node::Node(const Key &k, const Value &v, Color c, Node *p)
    : key(k), value(v), color(c), left(nullptr), right(nullptr), parent(p) {}

// 查询某节点
template<typename Key, typename Value>
typename MyRedBlackTree<Key, Value>::Node* MyRedBlackTree<Key, Value>::lookup(Key key){
    Node *cmpNode = root;
    while(cmpNode){
        if(key < cmpNode->key){
            cmpNode = cmpNode->left;
        }
        else if(key > cmpNode->key){
            cmpNode = cmpNode->right;
        }
        else{
            return cmpNode;
        }
    }
    return cmpNode;
}

// 右旋函数
template<typename Key, typename Value>
void MyRedBlackTree<Key, Value>::rightRotate(Node *node){
    Node *l_son = node->left;   // 获取当前节点的左子节点

    // 当前节点的左子树变成左子节点的右子树
    node->left = l_son->right;
    // 如果左子节点的右子树非空，更新其为父指针
    if(l_son->right){
        l_son->right->parent = node;
    }

    // 左子节点升为当前节点位置，并处理父节点关系
    l_son->parent = node->parent;
    // 如果当前节点是根结点，更新根结点为左子节点
    if(!node->parent){
        root = l_son;
    }
    // 如果当前节点使其父节点的左子节点，更新父节点的左子节点为左子节点
    else if(node == node->parent->left){
        node->parent->left = l_son;
    }
    // 如果当前节点使其父节点的右子节点，更新父节点的右子节点为左子节点
    else{
        node->parent->right = l_son;
    }

    // 完成右旋转，将当前节点称为左子节点的右子节点
    l_son->right = node;
    // 更新当前节点的父节点为左子节点
    node->parent = l_son;
}

// 左旋，是右旋的对称情况，逻辑和右旋是一样的
template<typename Key, typename Value>
void MyRedBlackTree<Key, Value>::leftRotate(Node *node){
    Node *r_son = node->right;
    node->right = r_son->left;
    if(r_son->left){
        r_son->left->parent = node;
    }

    r_son->parent = node->parent;
    if(!node->parent){
        root = r_son;
    }
    else if(node == node->parent->left){
        node->parent->left = r_son;
    }
    else{
        node->parent->right = r_son;
    }

    r_son->left = node;
    node->parent = r_son;
}

// 插入修复函数
template<typename Key, typename Value>
void MyRedBlackTree<Key, Value>::insertFixup(Node *target){
    // 当目标节点的父节点存在且父节点的颜色是红色时，需要修复
    while(target->parent && target->parent->color == Color::red){
        // 当目标节点的父节点是祖父节点的左子节点时 LL
        if(target->parent == target->parent->parent->left){
            Node *uncle = target->parent->parent->right;   // 叔叔节点
            // 如果叔叔节点存在且为红色，进行颜色调整
            if(uncle && uncle->color == Color::red){
                target->parent->color = Color::black;   // 父节点设为黑色
                uncle->color = Color::black;   // 叔叔节点设为黑色
                target->parent->parent->color = Color::red;   // 祖父节点设为红色
                target = target->parent->parent;   // 将祖父节点设为下一个目标节点，递归向上检查是否满足平衡条件
            }
            else{
                // 如果目标节点是父节点的右子节点，进行左旋转 LR
                if(target == target->parent->right){
                    target = target->parent;   // 更新目标节点为父节点
                    leftRotate(target);   // 对目标节点进行左旋使其满足LL
                }
                // 调整父节点和祖父节点颜色，并进行右旋转
                target->parent->color = Color::black;
                target->parent->parent->color = Color::red;
                rightRotate(target->parent->parent);
            }
        }
        // 当目标节点的父节点是祖父节点的右子节点时，与上面对称
        else{
            Node *uncle = target->parent->parent->left;
            if(uncle && uncle->color == Color::red){
                target->parent->color = Color::black;
                uncle->color = Color::black;
                target->parent->parent->color = Color::red;
                target = target->parent->parent;
            }
            else{
                if(target == target->parent->left){
                    target = target->parent;
                    rightRotate(target);
                }
                target->parent->color = Color::black;
                target->parent->parent->color = Color::red;
                leftRotate(target->parent->parent);
            }
        }
    }
    // 确保根结点始终为黑色
    root->color = Color::black;
}

// 插入节点函数
template<typename Key, typename Value>
void MyRedBlackTree<Key, Value>::insertNode(const Key &key, const Value &value){
    // 创建一个新节点，节点的颜色初始化为红色
    Node *newNode = new Node(key, value, Color::red);
    Node *parent = nullptr;   // 用于指向新节点的父节点
    Node *cmpNode = root;   // 用于比较的节点，初始化为根结点

    // 遍历树，找到新节点正确的位置
    while(cmpNode){
        parent = cmpNode;   // 保留当前节点作为新节点的潜在父节点
        // 下面的查找操作就是正常的BST的查找操作
        if(newNode->key < cmpNode->key){
            cmpNode = cmpNode->left;
        }
        else if(newNode->key > cmpNode->key){
            cmpNode = cmpNode->right;
        }
        else{
            delete newNode;
            return;
        }
    }

    // 树的大小增加
    ++size;

    // 将新节点的父节点设置为找到的父节点的位置
    newNode->parent = parent;
    // 如果父节点为空，说明树是空的，新节点成为根结点
    if(!parent){
        root = newNode;
    }
    // 如果新节点的键小于父节点的键，将新节点插入父节点的左子树
    else if(newNode->key < parent->key){
        parent->left = newNode;
    }
    else{
        parent->right = newNode;
    }

    // 插入新节点后，调用insertFixup函数来修复可能破坏的红黑树性质
    insertFixup(newNode);
}

// 中序遍历
template<typename Key, typename Value>
void MyRedBlackTree<Key, Value>::inorderTraversal(Node *node) const{
    if(node){
        inorderTraversal(node->left);
        std::cout << node->key << " ";
        std::cout << node->value << " ";
        inorderTraversal(node->right);
    }
}

// 辅助函数，用新节点替换旧节点
template<typename Key, typename Value>
void MyRedBlackTree<Key, Value>::replaceNode(Node *targetNode, Node *newNode){
    if(!targetNode->parent){
        root = newNode;
    }
    else if(targetNode == targetNode->parent->left){
        targetNode->parent->left = newNode;
    }
    else{
        targetNode->parent->right = newNode;
    }
    if(newNode){
        newNode->parent = targetNode->parent;
    }
}

// 寻找以某个节点为根节点的子树中的最小节点
template<typename Key, typename Value>
typename MyRedBlackTree<Key, Value>::Node* MyRedBlackTree<Key, Value>::findMinNode(Node *node){
    while(node->left){
        node = node->left;
    }
    return node;
}

// removeFixup函数用于在删除节点后恢复红黑树的性质
// 删除节点的情况太复杂了，一点看不懂
template<typename Key, typename Value>
void MyRedBlackTree<Key, Value>::removeFixup(Node *node){
    // 如果节点为Nil并且没有父节点，说明它是唯一的节点，直接返回
    if(node == Nil && node->parent == nullptr){
        return;
    }

    // 没有到达根结点时继续循环
    while(node != root){
        // 如果节点是其父节点的左子节点
        if (node == node->parent->left) {
            // 兄弟节点是节点父亲的右子节点
            Node *sibling = node->parent->right;

            // 情况1：节点的兄弟节点是红色
            if (getColor(sibling) == Color::red) {
                // 重新着色兄弟节点和父节点，并进行左旋
                setColor(sibling, Color::black);
                setColor(node->parent, Color::red);
                leftRotate(node->parent);
                // 旋转后更新兄弟节点
                sibling = node->parent->right;
            }

            // 情况2：兄弟节点的两个子节点都是黑色
            if (getColor(sibling->left) == Color::black && getColor(sibling->right) == Color::black) {
            // 重新着色兄弟节点并向上移动
                setColor(sibling, Color::red);
                node = node->parent;
                // 如果父节点是红色，将其改为黑色并结束
                if (node->color == Color::red) {
                    node->color = Color::black;
                    node = root;
                }
            } 
            else {
                // 情况3：兄弟节点的右子节点是黑色（左子节点是红色）
                if (getColor(sibling->right) == Color::black) {
                    // 重新着色兄弟节点和兄弟节点的左子节点，并进行右旋
                    setColor(sibling->left, Color::black);
                    setColor(sibling, Color::red);
                    rightRotate(sibling);
                    // 旋转后更新兄弟节点
                    sibling = node->parent->right;
                }

                // 情况4：兄弟节点的右子节点是红色
                setColor(sibling, getColor(node->parent));
                setColor(node->parent, Color::black);
                setColor(sibling->right, Color::black);
                leftRotate(node->parent);
                // 移动到根节点结束
                node = root;
            }
        } 
        else {
            // 当节点是其父节点的右子节点时，对称的情况
            Node *sibling = node->parent->left;

            if (getColor(sibling) == Color::red) {
                setColor(sibling, Color::black);
                setColor(node->parent, Color::red);
                rightRotate(node->parent);
                sibling = node->parent->left;
            }

            if (getColor(sibling->right) == Color::black && getColor(sibling->left) == Color::black) {
                setColor(sibling, Color::red);
                node = node->parent;
                if (node->color == Color::red) {
                    node->color = Color::black;
                    node = root;
                }
            } 
            else {
                if (getColor(sibling->left) == Color::black) {
                    setColor(sibling->right, Color::black);
                    setColor(sibling, Color::red);
                    leftRotate(sibling);
                    sibling = node->parent->left;
                }
                setColor(sibling, getColor(node->parent));
                setColor(node->parent, Color::black);
                setColor(sibling->left, Color::black);
                rightRotate(node->parent);
                node = root;
            }
        }
    }
    // 确保当前节点是黑色的，以维持红黑树性质
    setColor(node, Color::black);
}

// 获取颜色, 空指针为黑色
template<typename Key, typename Value>
Color MyRedBlackTree<Key, Value>::getColor(Node *node){
    if(node == nullptr){
        return Color::black;
    }
    return node->color;
}

// 设置节点颜色
template<typename Key, typename Value>
void MyRedBlackTree<Key, Value>::setColor(Node *node, Color color){
    if(node == nullptr){
        return;
    }
    node->color = color;
}

// 取消Nil哨兵的连接
template<typename Key, typename Value>
void MyRedBlackTree<Key, Value>::dieConnectNil(){
    if(Nil == nullptr){
        return;
    }
    if(Nil->parent != nullptr){
        if(Nil == Nil->parent->left){
            Nil->parent->left = nullptr;
        }
        else{
            Nil->parent->right = nullptr;
        }
    }
}

// 删除节点
template<typename Key, typename Value>
void MyRedBlackTree<Key, Value>::deleteNode(Node *del){
    Node *rep = del; // rep（替代节点）初始指向要删除的节点
    Node *child = nullptr;      // 要删除节点的孩子节点
    Node *parentRP;             // 替代节点的父节点
    Color origCol = rep->color; // 保存要删除节点的原始颜色

    // 如果删除节点没有左孩子
    if (!del->left) {
        rep = del->right;        // 替代节点指向删除节点的右孩子
        parentRP = del->parent;  // 更新替代节点的父节点
        origCol = getColor(rep); // 获取替代节点的颜色
        replaceNode(del, rep);   // 用替代节点替换删除节点
    }
    // 如果删除节点没有右孩子
    else if (!del->right) {
        rep = del->left;         // 替代节点指向删除节点的左孩子
        parentRP = del->parent;  // 更新替代节点的父节点
        origCol = getColor(rep); // 获取替代节点的颜色
        replaceNode(del, rep);   // 用替代节点替换删除节点
    }
    // 如果删除节点有两个孩子
    else {
        rep = findMinNode(del->right); // 找到删除节点右子树中的最小节点作为替代节点
        origCol = rep->color; // 保存替代节点的原始颜色
        // 如果替代节点不是删除节点的直接右孩子
        if (rep != del->right) {
            parentRP = rep->parent; // 更新替代节点的父节点
            child = rep->right; // 替代节点的右孩子变成要处理的孩子节点
            parentRP->left = child; // 替代节点的父节点的左孩子指向替代节点的孩子（因为替代节点是最小节点，所以不可能有左孩子）
            if (child != nullptr) {
                child->parent = parentRP; // 如果替代节点的孩子存在，则更新其父节点
            }
            // 将替代节点放到删除节点的位置
            del->left->parent = rep;
            del->right->parent = rep;
            rep->left = del->left;
            rep->right = del->right;
            // 如果删除节点有父节点，更新父节点的孩子指向
            if (del->parent != nullptr) {
            if (del == del->parent->left) {
                del->parent->left = rep;
                rep->parent = del->parent;
            } else {
                del->parent->right = rep;
                rep->parent = del->parent;
            }
            }
            // 如果删除节点没有父节点，说明它是根节点
            else {
            root = rep;
            root->parent = nullptr;
            }
        }
        // 如果替代节点是删除节点的直接右孩子
        else {
            child = rep->right; // 孩子节点指向替代节点的右孩子
            rep->left = del->left; // 替代节点的左孩子指向删除节点的左孩子
            del->left->parent = rep; // 更新左孩子的父节点
            // 更新删除节点父节点的孩子指向
            if (del->parent != nullptr) {
                if (del == del->parent->left) {
                    del->parent->left = rep;
                    rep->parent = del->parent;
                } else {
                    del->parent->right = rep;
                    rep->parent = del->parent;
                }
            }
            // 如果删除节点是根节点
            else {
                root = rep;
                root->parent = nullptr;
            }
            parentRP = rep; // 更新替代节点的父节点
        }
    }

    // 如果替代节点存在，更新其颜色为删除节点的颜色
    if (rep != nullptr) {
        rep->color = del->color;
    }
    // 如果替代节点不存在，将删除节点的颜色赋给origCol变量
    else {
        origCol = del->color;
    }

    // 如果原始颜色是黑色，需要进行额外的修复操作，因为黑色节点的删除可能会破坏红黑树的性质
    if (origCol == Color::black) {
        // 如果存在孩子节点，进行修复操作
        if (child != nullptr) {
            removeFixup(child);
        }
        // 如果不存在孩子节点，将Nil节点（代表空节点）的父节点设置为替代节点的父节点
        else {
            Nil->parent = parentRP;
            // 如果替代节点的父节点存在，设置其对应的孩子指针为Nil节点
            if (parentRP != nullptr) {
            if (parentRP->left == nullptr) {
                parentRP->left = Nil;
            } else {
                parentRP->right = Nil;
            }
            }
            // 进行修复操作
            removeFixup(Nil);
            // 断开Nil节点与树的连接，因为在红黑树中Nil节点通常是单独存在的
            dieConnectNil();
        }
    }

    // 删除节点
    delete del;
}

// 构造函数
template<typename Key, typename Value>
MyRedBlackTree<Key, Value>::MyRedBlackTree() : root(nullptr), size(0), Nil(new Node()){
    Nil->color = Color::black;
}

// 插入操作
template<typename Key, typename Value>
void MyRedBlackTree<Key, Value>::insert(const Key &key, const Value &value){
    insertNode(key, value);
}

// 删除操作
template<typename Key, typename Value>
void MyRedBlackTree<Key, Value>::remove(const Key &key){
    Node *nodeToBeRemoved = lookup(key);
    if(nodeToBeRemoved != nullptr){
        deleteNode(nodeToBeRemoved);
        --size;
    }
}

template<typename Key, typename Value>
Value* MyRedBlackTree<Key, Value>::at(const Key &key){
    Node *ans = lookup(key);
    if(ans != nullptr){
        return &ans->value;
    }
    return nullptr;
}

template<typename Key, typename Value>
int MyRedBlackTree<Key, Value>::getSize(){
    return size;
}

template<typename Key, typename Value>
bool MyRedBlackTree<Key, Value>::empty(){
    return size == 0;
}

// 中序遍历打印
template<typename Key, typename Value>
void MyRedBlackTree<Key, Value>::print(){
    inorderTraversal(root);
    std::cout << std::endl;
}

template<typename Key, typename Value>
void MyRedBlackTree<Key, Value>::clear(){
    deleteNode(root);
    size = 0;
}

// 析构函数
template<typename Key, typename Value>
MyRedBlackTree<Key, Value>::~MyRedBlackTree(){
    // 释放节点内存
    deleteTree(root);
}

// 递归释放节点内存
template<typename Key, typename Value>
void MyRedBlackTree<Key, Value>::deleteTree(Node *node){
    if(node){
        deleteTree(node->left);
        deleteTree(node->right);
        delete node;
    }
}