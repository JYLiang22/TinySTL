- [目的](#目的)
- [测试文件介绍](#测试文件介绍)
  - [输入介绍](#输入介绍)
  - [输出介绍](#输出介绍)
- [与标准库的区别](#与标准库的区别)


# 目的

需要设计一个 HashTable，并实现以下功能：

1. 基础功能

    构造函数：初始化 HashTable 实例
    析构函数：清理资源，确保无内存泄露

2. 核心功能

    在 HashTable 中添加键值对
    删除 HashTable 中的键值对
    查询 HashTable 中的键值对
    获取 HashTable 中键值对的数量
    获取 HashTable 中的所有键值对

3. 高级功能

    实现键值对数量达到一定的阈值后，自动扩容的功能


# 测试文件介绍


## 输入介绍

包含多行输入，第一行为正整数 N, 代表后续有 N 行命令序列。<br>
接下来 N 行，每行包含一个命令，命令格式为 [operation] [parameters] ，具体命令如下：

```
insert 命令：
格式：insert [key] [value]
功能：在 HashTable 中添加键值对，如果键已经存在，则不进行任何操作

erase 命令：
格式：erase [key]
功能：删除 HashTable 中的键值对，如果键不存在，则不进行任何操作

find 命令：
格式：find [key]
功能：查询 HashTable 中的键值对

size 命令：
格式：size
功能：输出 HashTable 中键值对的数量

print 命令：
格式：print
功能：输出 HashTable 中所有键值对

clear 命令：
格式：clear
功能：清空哈希表
```


## 输出介绍

输出为每行命令执行后的结果，具体输出格式如下：

```
insert 命令: 无输出
erase 命令: 无输出
find 命令: 输出一个整数，独占一行，代表 key 对应的 value 值，如果 HashTable 中不存在对应的 key，则输出 not exsit
size 命令: 输出一个整数，独站一行，表示 HashTable 中键值对的数量
print 命令: 打印哈希表中所有键值对，格式为 [key1] [value1] [key2] [value2]...每个数字后都有一个空格，打印结果独占一行，如果 HashTable 中不存在键值对，则打印 empty
clear 命令: 无输出
```


# 与标准库的区别

实现的哈希表是一个简化版的哈希表，它使用链表来处理哈希冲突，这种方法也被称为分离链接法。以下是该版本的实现与标准模板库（STL）中的std::unordered_set或std::unordered_map所依赖的哈希表的一些区别：

1. 模板参数：

    - 我们的实现只接受键类型Key和哈希函数Hash作为模板参数。
    - STL的std::unordered_set和std::unordered_map有更多模板参数，如键的类型、值的类型、哈希函数、键的相等函数、分配器等。

2. 负载因子和自动重哈希：

    - 我们的实现在负载因子超过0.75时自动重哈希并且只能增加到当前大小的两倍。
    - STL的哈希表容器提供更多灵活性，可以调整负载因子，并且有更复杂的重哈希策略。

3. 内存分配：

    - 我们的实现使用std::list来管理冲突，这会导致多次单独的内存分配。
    - STL通常使用更高效的内存分配策略，比如预分配内存池来减少分配次数和提升性能。

4. 迭代器支持：

    - 我们的实现没有提供迭代器支持。
    - STL提供了完整的迭代器支持，允许用户方便地遍历容器中的元素。

5. 功能丰富性：

    - 我们的哈希表实现了基础的插入、删除和查找功能。
    - STL的哈希表容器提供了更丰富的接口，如emplace, count, bucket, bucket_count, bucket_size, load_factor, max_load_factor, rehash, reserve等。

6. 异常安全性：

    - 我们的实现没有显示地处理异常安全性问题。
    - STL的实现通常保证基本的异常安全性，并在某些操作中提供强异常安全性保证。

7. 优化：

    - 我们的实现是一个基本的哈希表，可能没有针对性能进行优化。
    - STL的实现被高度优化以提供良好的性能，特别是在大数据量下。

8. 平台兼容性和移植性：

    - 我们的实现理论上应该是跨平台的，但可能需要针对不同平台进行调整。
    - STL容器已经被广泛用于各种平台，并且被广大社区所测试，具有很高的兼容性和稳定性。

9. 接口一致性：

    - 我们的实现可能没有遵守STL容器接口的标准命名和行为。
    - STL容器遵循一致的接口和命名规范，这有助于程序员理解和使用。

这些区别并不是说我们的实现不好，而是说明了STL容器在设计时考虑到了许多复杂的场景和需求，使得它们在通用性、性能和易用性方面都非常强大。用户定义的数据结构通常更适合解决特定问题或用例，而STL容器则为大多数常见情况提供了良好的默认选择。